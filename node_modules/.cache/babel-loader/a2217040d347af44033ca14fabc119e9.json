{"ast":null,"code":"import _slicedToArray from\"/Users/xcodedeveloper/Desktop/grade0swap/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import _regeneratorRuntime from\"/Users/xcodedeveloper/Desktop/grade0swap/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/Users/xcodedeveloper/Desktop/grade0swap/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import{Contract,ethers}from\"ethers\";import{fetchReserves,getDecimals}from\"../ethereumFunctions\";var ERC20=require(\"../build/ERC20.json\");var PAIR=require(\"../build/IUniswapV2Pair.json\");// Function used to add Liquidity to any pair of tokens or token-AUT\n// To work correctly, there needs to be 9 arguments:\n//    `address1` - An Ethereum address of the coin to add from (either a token or AUT)\n//    `address2` - An Ethereum address of the coin to add to (either a token or AUT)\n//    `amount1` - A float or similar number representing the value of address1's coin to add\n//    `amount2` - A float or similar number representing the value of address2's coin to add\n//    `amount1Min` - A float or similar number representing the minimum of address1's coin to add\n//    `amount2Min` - A float or similar number representing the minimum of address2's coin to add\n//    `routerContract` - The router contract to carry out this trade\n//    `accountAddress` - An Ethereum address of the current user's account\n//    `provider` - The current provider\n//    `signer` - The current signer\nexport function addLiquidity(_x,_x2,_x3,_x4,_x5,_x6,_x7,_x8,_x9){return _addLiquidity.apply(this,arguments);}// Function used to remove Liquidity from any pair of tokens or token-AUT\n// To work correctly, there needs to be 9 arguments:\n//    `address1` - An Ethereum address of the coin to recieve (either a token or AUT)\n//    `address2` - An Ethereum address of the coin to recieve (either a token or AUT)\n//    `liquidity_tokens` - A float or similar number representing the value of liquidity tokens you will burn to get tokens back\n//    `amount1Min` - A float or similar number representing the minimum of address1's coin to recieve\n//    `amount2Min` - A float or similar number representing the minimum of address2's coin to recieve\n//    `routerContract` - The router contract to carry out this trade\n//    `accountAddress` - An Ethereum address of the current user's account\n//    `provider` - The current provider\n//    `signer` - The current signer\nfunction _addLiquidity(){_addLiquidity=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(address1,address2,amount1,amount2,amount1min,amount2min,routerContract,account,signer){var token1,token2,token1Decimals,token2Decimals,amountIn1,amountIn2,amount1Min,amount2Min,time,deadline,wethAddress;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:token1=new Contract(address1,ERC20.abi,signer);token2=new Contract(address2,ERC20.abi,signer);_context.next=4;return getDecimals(token1);case 4:token1Decimals=_context.sent;_context.next=7;return getDecimals(token2);case 7:token2Decimals=_context.sent;amountIn1=ethers.utils.parseUnits(amount1,token1Decimals);amountIn2=ethers.utils.parseUnits(amount2,token2Decimals);amount1Min=ethers.utils.parseUnits(amount1min,token1Decimals);amount2Min=ethers.utils.parseUnits(amount2min,token2Decimals);time=Math.floor(Date.now()/1000)+200000;deadline=ethers.BigNumber.from(time);_context.next=16;return token1.approve(routerContract.address,amountIn1);case 16:_context.next=18;return token2.approve(routerContract.address,amountIn2);case 18:_context.next=20;return routerContract.WETH();case 20:wethAddress=_context.sent;console.log([address1,address2,amountIn1,amountIn2,amount1Min,amount2Min,account,deadline]);if(!(address1===wethAddress)){_context.next=27;break;}_context.next=25;return routerContract.addLiquidityETH(address2,amountIn2,amount2Min,amount1Min,account,deadline,{value:amountIn1});case 25:_context.next=34;break;case 27:if(!(address2===wethAddress)){_context.next=32;break;}_context.next=30;return routerContract.addLiquidityETH(address1,amountIn1,amount1Min,amount2Min,account,deadline,{value:amountIn2});case 30:_context.next=34;break;case 32:_context.next=34;return routerContract.addLiquidity(address1,address2,amountIn1,amountIn2,amount1Min,amount2Min,account,deadline);case 34:case\"end\":return _context.stop();}}},_callee);}));return _addLiquidity.apply(this,arguments);}export function removeLiquidity(_x10,_x11,_x12,_x13,_x14,_x15,_x16,_x17,_x18){return _removeLiquidity.apply(this,arguments);}function _removeLiquidity(){_removeLiquidity=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(address1,address2,liquidity_tokens,amount1min,amount2min,routerContract,account,signer,factory){var token1,token2,token1Decimals,token2Decimals,Getliquidity,liquidity,amount1Min,amount2Min,time,deadline,wethAddress,pairAddress,pair;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:token1=new Contract(address1,ERC20.abi,signer);token2=new Contract(address2,ERC20.abi,signer);_context2.next=4;return getDecimals(token1);case 4:token1Decimals=_context2.sent;_context2.next=7;return getDecimals(token2);case 7:token2Decimals=_context2.sent;Getliquidity=function Getliquidity(liquidity_tokens){if(liquidity_tokens<0.001){return ethers.BigNumber.from(liquidity_tokens*Math.pow(10,18));}return ethers.utils.parseUnits(String(liquidity_tokens),18);};liquidity=Getliquidity(liquidity_tokens);console.log('liquidity: ',liquidity);amount1Min=ethers.utils.parseUnits(String(amount1min),token1Decimals);amount2Min=ethers.utils.parseUnits(String(amount2min),token2Decimals);time=Math.floor(Date.now()/1000)+200000;deadline=ethers.BigNumber.from(time);_context2.next=17;return routerContract.WETH();case 17:wethAddress=_context2.sent;_context2.next=20;return factory.getPair(address1,address2);case 20:pairAddress=_context2.sent;pair=new Contract(pairAddress,PAIR.abi,signer);_context2.next=24;return pair.approve(routerContract.address,liquidity);case 24:console.log([address1,address2,Number(liquidity),Number(amount1Min),Number(amount2Min),account,deadline]);if(!(address1===wethAddress)){_context2.next=30;break;}_context2.next=28;return routerContract.removeLiquidityETH(address2,liquidity,amount2Min,amount1Min,account,deadline);case 28:_context2.next=37;break;case 30:if(!(address2===wethAddress)){_context2.next=35;break;}_context2.next=33;return routerContract.removeLiquidityETH(address1,liquidity,amount1Min,amount2Min,account,deadline);case 33:_context2.next=37;break;case 35:_context2.next=37;return routerContract.removeLiquidity(address1,address2,liquidity,amount1Min,amount2Min,account,deadline);case 37:case\"end\":return _context2.stop();}}},_callee2);}));return _removeLiquidity.apply(this,arguments);}var quote=function quote(amount1,reserve1,reserve2){var amount2=amount1*(reserve2/reserve1);return[amount2];};// Function used to get a quote of the liquidity addition\n//    `address1` - An Ethereum address of the coin to recieve (either a token or AUT)\n//    `address2` - An Ethereum address of the coin to recieve (either a token or AUT)\n//    `amountA_desired` - The prefered value of the first token that the user would like to deploy as liquidity\n//    `amountB_desired` - The prefered value of the second token that the user would like to deploy as liquidity\n//    `factory` - The current factory\n//    `signer` - The current signer\nfunction quoteMintLiquidity(_x19,_x20,_x21,_x22,_x23,_x24){return _quoteMintLiquidity.apply(this,arguments);}function _quoteMintLiquidity(){_quoteMintLiquidity=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee4(address1,address2,amountA,amountB,factory,signer){var MINIMUM_LIQUIDITY,_reserveA,_reserveB,totalSupply,_yield$factory$getPai,_yield$factory$getPai2,token1,token2,token1Decimals,token2Decimals,valueA,valueB,reserveA,reserveB;return _regeneratorRuntime.wrap(function _callee4$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:MINIMUM_LIQUIDITY=1000;_reserveA=0;_reserveB=0;totalSupply=0;_context4.next=6;return factory.getPair(address1,address2).then(/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(pairAddress){var pair,reservesRaw,_reserveA2,_reserveB2,_totalSupply,_totalSupply2;return _regeneratorRuntime.wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:if(!(pairAddress!=='0x0000000000000000000000000000000000000000')){_context3.next=14;break;}pair=new Contract(pairAddress,PAIR.abi,signer);_context3.next=4;return fetchReserves(address1,address2,pair,signer);case 4:reservesRaw=_context3.sent;// Returns the reserves already formated as ethers\n_reserveA2=reservesRaw[0];_reserveB2=reservesRaw[1];_context3.next=9;return pair.totalSupply();case 9:_totalSupply=_context3.sent;_totalSupply2=Number(ethers.utils.formatEther(_totalSupply));return _context3.abrupt(\"return\",[_reserveA2,_reserveB2,_totalSupply2]);case 14:return _context3.abrupt(\"return\",[0,0,0]);case 15:case\"end\":return _context3.stop();}}},_callee3);}));return function(_x36){return _ref.apply(this,arguments);};}());case 6:_yield$factory$getPai=_context4.sent;_yield$factory$getPai2=_slicedToArray(_yield$factory$getPai,3);_reserveA=_yield$factory$getPai2[0];_reserveB=_yield$factory$getPai2[1];totalSupply=_yield$factory$getPai2[2];token1=new Contract(address1,ERC20.abi,signer);token2=new Contract(address2,ERC20.abi,signer);// Need to do all this decimals work to account for 0 decimal numbers\n_context4.next=15;return getDecimals(token1);case 15:token1Decimals=_context4.sent;_context4.next=18;return getDecimals(token2);case 18:token2Decimals=_context4.sent;valueA=amountA*Math.pow(10,token1Decimals);valueB=amountB*Math.pow(10,token2Decimals);reserveA=_reserveA*Math.pow(10,token1Decimals);reserveB=_reserveB*Math.pow(10,token2Decimals);if(!(totalSupply==0)){_context4.next=25;break;}return _context4.abrupt(\"return\",Math.sqrt(valueA*valueB-MINIMUM_LIQUIDITY)*Math.pow(10,-18));case 25:;return _context4.abrupt(\"return\",Math.min(valueA*totalSupply/reserveA,valueB*totalSupply/reserveB));case 27:case\"end\":return _context4.stop();}}},_callee4);}));return _quoteMintLiquidity.apply(this,arguments);};export function quoteAddLiquidity(_x25,_x26,_x27,_x28,_x29,_x30){return _quoteAddLiquidity.apply(this,arguments);}// Function used to get a quote of the liquidity removal\n//    `address1` - An Ethereum address of the coin to recieve (either a token or AUT)\n//    `address2` - An Ethereum address of the coin to recieve (either a token or AUT)\n//    `liquidity` - The amount of liquidity tokens the user will burn to get their tokens back\n//    `factory` - The current factory\n//    `signer` - The current signer\nfunction _quoteAddLiquidity(){_quoteAddLiquidity=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee5(address1,address2,amountADesired,amountBDesired,factory,signer){var pairAddress,pair,reservesRaw,reserveA,reserveB,amountOut,amountBOptimal,_amountOut,amountAOptimal,_amountOut2;return _regeneratorRuntime.wrap(function _callee5$(_context5){while(1){switch(_context5.prev=_context5.next){case 0:_context5.next=2;return factory.getPair(address1,address2);case 2:pairAddress=_context5.sent;pair=new Contract(pairAddress,PAIR.abi,signer);_context5.next=6;return fetchReserves(address1,address2,pair,signer);case 6:reservesRaw=_context5.sent;// Returns the reserves already formated as ethers\nreserveA=reservesRaw[0];reserveB=reservesRaw[1];if(!(reserveA===0&&reserveB===0)){_context5.next=16;break;}_context5.next=12;return quoteMintLiquidity(address1,address2,amountADesired,amountBDesired,factory,signer);case 12:amountOut=_context5.sent;return _context5.abrupt(\"return\",[amountADesired,amountBDesired,amountOut.toPrecision(8)]);case 16:amountBOptimal=quote(amountADesired,reserveA,reserveB);if(!(amountBOptimal<=amountBDesired)){_context5.next=24;break;}_context5.next=20;return quoteMintLiquidity(address1,address2,amountADesired,amountBOptimal,factory,signer);case 20:_amountOut=_context5.sent;return _context5.abrupt(\"return\",[amountADesired,amountBOptimal,_amountOut.toPrecision(8)]);case 24:amountAOptimal=quote(amountBDesired,reserveB,reserveA);_context5.next=27;return quoteMintLiquidity(address1,address2,amountAOptimal,amountBDesired,factory,signer);case 27:_amountOut2=_context5.sent;return _context5.abrupt(\"return\",[amountAOptimal,amountBDesired,_amountOut2.toPrecision(8)]);case 29:case\"end\":return _context5.stop();}}},_callee5);}));return _quoteAddLiquidity.apply(this,arguments);}export function quoteRemoveLiquidity(_x31,_x32,_x33,_x34,_x35){return _quoteRemoveLiquidity.apply(this,arguments);}function _quoteRemoveLiquidity(){_quoteRemoveLiquidity=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee6(address1,address2,liquidity,factory,signer){var pairAddress,pair,reservesRaw,reserveA,reserveB,feeOn,_kLast,kLast,_totalSupply,totalSupply,feeLiquidity,Aout,Bout;return _regeneratorRuntime.wrap(function _callee6$(_context6){while(1){switch(_context6.prev=_context6.next){case 0:_context6.next=2;return factory.getPair(address1,address2);case 2:pairAddress=_context6.sent;console.log(\"pair address\",pairAddress);pair=new Contract(pairAddress,PAIR.abi,signer);_context6.next=7;return fetchReserves(address1,address2,pair,signer);case 7:reservesRaw=_context6.sent;// Returns the reserves already formated as ethers\nreserveA=reservesRaw[0];reserveB=reservesRaw[1];_context6.next=12;return factory.feeTo();case 12:_context6.t0=_context6.sent;feeOn=_context6.t0!==0x0000000000000000000000000000000000000000;_context6.next=16;return pair.kLast();case 16:_kLast=_context6.sent;kLast=Number(ethers.utils.formatEther(_kLast));_context6.next=20;return pair.totalSupply();case 20:_totalSupply=_context6.sent;totalSupply=Number(ethers.utils.formatEther(_totalSupply));if(feeOn&&kLast>0){feeLiquidity=totalSupply*(Math.sqrt(reserveA*reserveB)-Math.sqrt(kLast))/(5*Math.sqrt(reserveA*reserveB)+Math.sqrt(kLast));totalSupply=totalSupply+feeLiquidity;}Aout=reserveA*liquidity/totalSupply;Bout=reserveB*liquidity/totalSupply;return _context6.abrupt(\"return\",[liquidity,Aout,Bout]);case 26:case\"end\":return _context6.stop();}}},_callee6);}));return _quoteRemoveLiquidity.apply(this,arguments);}","map":{"version":3,"sources":["/Users/xcodedeveloper/Desktop/grade0swap/src/Liquidity/LiquidityFunctions.js"],"names":["Contract","ethers","fetchReserves","getDecimals","ERC20","require","PAIR","addLiquidity","address1","address2","amount1","amount2","amount1min","amount2min","routerContract","account","signer","token1","abi","token2","token1Decimals","token2Decimals","amountIn1","utils","parseUnits","amountIn2","amount1Min","amount2Min","time","Math","floor","Date","now","deadline","BigNumber","from","approve","address","WETH","wethAddress","console","log","addLiquidityETH","value","removeLiquidity","liquidity_tokens","factory","Getliquidity","String","liquidity","getPair","pairAddress","pair","Number","removeLiquidityETH","quote","reserve1","reserve2","quoteMintLiquidity","amountA","amountB","MINIMUM_LIQUIDITY","_reserveA","_reserveB","totalSupply","then","reservesRaw","reserveA","reserveB","_totalSupply","formatEther","valueA","valueB","sqrt","min","quoteAddLiquidity","amountADesired","amountBDesired","amountOut","toPrecision","amountBOptimal","amountAOptimal","quoteRemoveLiquidity","feeTo","feeOn","kLast","_kLast","feeLiquidity","Aout","Bout"],"mappings":"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","sourcesContent":["import { Contract, ethers } from \"ethers\";\nimport { fetchReserves, getDecimals } from \"../ethereumFunctions\";\n\nconst ERC20 = require(\"../build/ERC20.json\");\nconst PAIR = require(\"../build/IUniswapV2Pair.json\");\n\n// Function used to add Liquidity to any pair of tokens or token-AUT\n// To work correctly, there needs to be 9 arguments:\n//    `address1` - An Ethereum address of the coin to add from (either a token or AUT)\n//    `address2` - An Ethereum address of the coin to add to (either a token or AUT)\n//    `amount1` - A float or similar number representing the value of address1's coin to add\n//    `amount2` - A float or similar number representing the value of address2's coin to add\n//    `amount1Min` - A float or similar number representing the minimum of address1's coin to add\n//    `amount2Min` - A float or similar number representing the minimum of address2's coin to add\n//    `routerContract` - The router contract to carry out this trade\n//    `accountAddress` - An Ethereum address of the current user's account\n//    `provider` - The current provider\n//    `signer` - The current signer\nexport async function addLiquidity(\n  address1,\n  address2,\n  amount1,\n  amount2,\n  amount1min,\n  amount2min,\n  routerContract,\n  account,\n  signer\n) {\n  const token1 = new Contract(address1, ERC20.abi, signer);\n  const token2 = new Contract(address2, ERC20.abi, signer);\n\n  const token1Decimals = await getDecimals(token1);\n  const token2Decimals = await getDecimals(token2);\n\n  const amountIn1 = ethers.utils.parseUnits(amount1, token1Decimals);\n  const amountIn2 = ethers.utils.parseUnits(amount2, token2Decimals);\n\n  const amount1Min = ethers.utils.parseUnits(amount1min, token1Decimals);\n  const amount2Min = ethers.utils.parseUnits(amount2min, token2Decimals);\n\n  const time = Math.floor(Date.now() / 1000) + 200000;\n  const deadline = ethers.BigNumber.from(time);\n\n  await token1.approve(routerContract.address, amountIn1);\n  await token2.approve(routerContract.address, amountIn2);\n\n  const wethAddress = await routerContract.WETH();\n\n  console.log([\n    address1,\n    address2,\n    amountIn1,\n    amountIn2,\n    amount1Min,\n    amount2Min,\n    account,\n    deadline,\n  ]);\n\n  if (address1 === wethAddress) {\n    // Eth + Token\n    await routerContract.addLiquidityETH(\n      address2,\n      amountIn2,\n      amount2Min,\n      amount1Min,\n      account,\n      deadline,\n      { value: amountIn1 }\n    );\n  } else if (address2 === wethAddress) {\n    // Token + Eth\n    await routerContract.addLiquidityETH(\n      address1,\n      amountIn1,\n      amount1Min,\n      amount2Min,\n      account,\n      deadline,\n      { value: amountIn2 }\n    );\n  } else {\n    // Token + Token\n    await routerContract.addLiquidity(\n      address1,\n      address2,\n      amountIn1,\n      amountIn2,\n      amount1Min,\n      amount2Min,\n      account,\n      deadline\n    );\n  }\n}\n\n// Function used to remove Liquidity from any pair of tokens or token-AUT\n// To work correctly, there needs to be 9 arguments:\n//    `address1` - An Ethereum address of the coin to recieve (either a token or AUT)\n//    `address2` - An Ethereum address of the coin to recieve (either a token or AUT)\n//    `liquidity_tokens` - A float or similar number representing the value of liquidity tokens you will burn to get tokens back\n//    `amount1Min` - A float or similar number representing the minimum of address1's coin to recieve\n//    `amount2Min` - A float or similar number representing the minimum of address2's coin to recieve\n//    `routerContract` - The router contract to carry out this trade\n//    `accountAddress` - An Ethereum address of the current user's account\n//    `provider` - The current provider\n//    `signer` - The current signer\nexport async function removeLiquidity(\n  address1,\n  address2,\n  liquidity_tokens,\n  amount1min,\n  amount2min,\n  routerContract,\n  account,\n  signer,\n  factory\n) {\n  const token1 = new Contract(address1, ERC20.abi, signer);\n  const token2 = new Contract(address2, ERC20.abi, signer);\n\n  const token1Decimals = await getDecimals(token1);\n  const token2Decimals = await getDecimals(token2);\n\n  const Getliquidity = (liquidity_tokens)=>{\n    if (liquidity_tokens < 0.001){\n      return ethers.BigNumber.from(liquidity_tokens*10**18);\n    }\n    return ethers.utils.parseUnits(String(liquidity_tokens), 18);\n  }\n\n  const liquidity = Getliquidity(liquidity_tokens);\n  console.log('liquidity: ', liquidity);\n\n  const amount1Min = ethers.utils.parseUnits(String(amount1min), token1Decimals);\n  const amount2Min = ethers.utils.parseUnits(String(amount2min), token2Decimals);\n\n  const time = Math.floor(Date.now() / 1000) + 200000;\n  const deadline = ethers.BigNumber.from(time);\n\n  const wethAddress = await routerContract.WETH();\n  const pairAddress = await factory.getPair(address1, address2);\n  const pair = new Contract(pairAddress, PAIR.abi, signer);\n\n  await pair.approve(routerContract.address, liquidity);\n\n  console.log([\n    address1,\n    address2,\n    Number(liquidity),\n    Number(amount1Min),\n    Number(amount2Min),\n    account,\n    deadline,\n  ]);\n\n  if (address1 === wethAddress) {\n    // Eth + Token\n    await routerContract.removeLiquidityETH(\n      address2,\n      liquidity,\n      amount2Min,\n      amount1Min,\n      account,\n      deadline\n    );\n  } else if (address2 === wethAddress) {\n    // Token + Eth\n    await routerContract.removeLiquidityETH(\n      address1,\n      liquidity,\n      amount1Min,\n      amount2Min,\n      account,\n      deadline\n    );\n  } else {\n    // Token + Token\n    await routerContract.removeLiquidity(\n      address1,\n      address2,\n      liquidity,\n      amount1Min,\n      amount2Min,\n      account,\n      deadline\n    );\n  }\n}\n\nconst quote = (amount1, reserve1, reserve2) => {\n  const amount2 = amount1 * (reserve2 / reserve1);\n  return [amount2];\n};\n\n// Function used to get a quote of the liquidity addition\n//    `address1` - An Ethereum address of the coin to recieve (either a token or AUT)\n//    `address2` - An Ethereum address of the coin to recieve (either a token or AUT)\n//    `amountA_desired` - The prefered value of the first token that the user would like to deploy as liquidity\n//    `amountB_desired` - The prefered value of the second token that the user would like to deploy as liquidity\n//    `factory` - The current factory\n//    `signer` - The current signer\n\nasync function quoteMintLiquidity(\n  address1,\n  address2,\n  amountA,\n  amountB,\n  factory,\n  signer\n){\n  const MINIMUM_LIQUIDITY = 1000;\n  let _reserveA = 0;\n  let _reserveB = 0;\n  let totalSupply = 0;\n  [_reserveA, _reserveB, totalSupply] = await factory.getPair(address1, address2).then(async (pairAddress) => {\n    if (pairAddress !== '0x0000000000000000000000000000000000000000'){\n      const pair = new Contract(pairAddress, PAIR.abi, signer);\n\n      const reservesRaw = await fetchReserves(address1, address2, pair, signer); // Returns the reserves already formated as ethers\n      const reserveA = reservesRaw[0];\n      const reserveB = reservesRaw[1];\n    \n      const _totalSupply = await pair.totalSupply();\n      const totalSupply = Number(ethers.utils.formatEther(_totalSupply));\n      return [reserveA, reserveB, totalSupply]\n    } else {\n      return [0,0,0]\n    }\n  });\n\n  const token1 = new Contract(address1, ERC20.abi, signer);\n  const token2 = new Contract(address2, ERC20.abi, signer);\n\n  // Need to do all this decimals work to account for 0 decimal numbers\n\n  const token1Decimals = await getDecimals(token1);\n  const token2Decimals = await getDecimals(token2);\n\n  const valueA = amountA*(10**token1Decimals);\n  const valueB = amountB*(10**token2Decimals);\n\n  const reserveA = _reserveA*(10**token1Decimals);\n  const reserveB = _reserveB*(10**token2Decimals);\n\n  if (totalSupply == 0){\n    return Math.sqrt(((valueA * valueB)-MINIMUM_LIQUIDITY))*10**(-18);\n  };\n  \n  return (\n    Math.min(valueA*totalSupply/reserveA, valueB*totalSupply/reserveB)\n  );\n};\n\nexport async function quoteAddLiquidity(\n  address1,\n  address2,\n  amountADesired,\n  amountBDesired,\n  factory,\n  signer\n) {\n\n  const pairAddress = await factory.getPair(address1, address2);\n  const pair = new Contract(pairAddress, PAIR.abi, signer);\n\n  const reservesRaw = await fetchReserves(address1, address2, pair, signer); // Returns the reserves already formated as ethers\n  const reserveA = reservesRaw[0];\n  const reserveB = reservesRaw[1];\n\n  if (reserveA === 0 && reserveB === 0) {\n    const amountOut = await quoteMintLiquidity(\n      address1,\n      address2,\n      amountADesired,\n      amountBDesired,\n      factory,\n      signer);\n    return [\n      amountADesired,\n      amountBDesired,\n      amountOut.toPrecision(8),\n    ];\n  } else {\n    const amountBOptimal = quote(amountADesired, reserveA, reserveB);\n    if (amountBOptimal <= amountBDesired) {\n      const amountOut = await quoteMintLiquidity(\n        address1,\n        address2,\n        amountADesired,\n        amountBOptimal,\n        factory,\n        signer);\n      return [\n        amountADesired,\n        amountBOptimal,\n        amountOut.toPrecision(8),\n      ];\n    } else {\n      const amountAOptimal = quote(\n        amountBDesired,\n        reserveB,\n        reserveA\n      );\n      const amountOut = await quoteMintLiquidity(\n        address1,\n        address2,\n        amountAOptimal,\n        amountBDesired,\n        factory,\n        signer);\n      return [\n        amountAOptimal,\n        amountBDesired,\n        amountOut.toPrecision(8),\n      ];\n    }\n  }\n}\n\n// Function used to get a quote of the liquidity removal\n//    `address1` - An Ethereum address of the coin to recieve (either a token or AUT)\n//    `address2` - An Ethereum address of the coin to recieve (either a token or AUT)\n//    `liquidity` - The amount of liquidity tokens the user will burn to get their tokens back\n//    `factory` - The current factory\n//    `signer` - The current signer\n\nexport async function quoteRemoveLiquidity(\n  address1,\n  address2,\n  liquidity,\n  factory,\n  signer\n) {\n  const pairAddress = await factory.getPair(address1, address2);\n  console.log(\"pair address\", pairAddress);\n  const pair = new Contract(pairAddress, PAIR.abi, signer);\n\n  const reservesRaw = await fetchReserves(address1, address2, pair, signer); // Returns the reserves already formated as ethers\n  const reserveA = reservesRaw[0];\n  const reserveB = reservesRaw[1];\n\n  const feeOn =\n    (await factory.feeTo()) !== 0x0000000000000000000000000000000000000000;\n\n  const _kLast = await pair.kLast();\n  const kLast = Number(ethers.utils.formatEther(_kLast));\n\n  const _totalSupply = await pair.totalSupply();\n  let totalSupply = Number(ethers.utils.formatEther(_totalSupply));\n\n  if (feeOn && kLast > 0) {\n    const feeLiquidity =\n      (totalSupply * (Math.sqrt(reserveA * reserveB) - Math.sqrt(kLast))) /\n      (5 * Math.sqrt(reserveA * reserveB) + Math.sqrt(kLast));\n    totalSupply = totalSupply + feeLiquidity;\n  }\n\n  const Aout = (reserveA * liquidity) / totalSupply;\n  const Bout = (reserveB * liquidity) / totalSupply;\n\n  return [liquidity, Aout, Bout];\n}\n"]},"metadata":{},"sourceType":"module"}